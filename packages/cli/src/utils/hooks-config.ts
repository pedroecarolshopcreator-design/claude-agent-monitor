import { DEFAULT_SERVER_PORT } from "@claudecam/shared";

export interface HookHandler {
  type: "command";
  command: string;
  timeout?: number;
}

export interface HookEntry {
  matcher?: string;
  hooks: HookHandler[];
}

export interface HooksConfig {
  PreToolUse: HookEntry[];
  PostToolUse: HookEntry[];
  PostToolUseFailure: HookEntry[];
  Notification: HookEntry[];
  Stop: HookEntry[];
  SubagentStop: HookEntry[];
  SubagentStart: HookEntry[];
  PreCompact: HookEntry[];
  SessionStart: HookEntry[];
  SessionEnd: HookEntry[];
  UserPromptSubmit: HookEntry[];
}

const CAM_HOOK_MARKER = "cam-hook";

export function generateHooksConfig(port?: number): HooksConfig {
  const prefix = port && port !== DEFAULT_SERVER_PORT
    ? `CAM_PORT=${port} `
    : "";

  function makeEntry(subcommand: string, matcher?: string): HookEntry {
    const entry: HookEntry = {
      hooks: [{ type: "command", command: `${prefix}cam-hook ${subcommand}` }],
    };
    if (matcher) entry.matcher = matcher;
    return entry;
  }

  return {
    PreToolUse: [makeEntry("pre-tool-use", "*")],
    PostToolUse: [makeEntry("post-tool-use", "*")],
    PostToolUseFailure: [makeEntry("post-tool-use-failure", "*")],
    Notification: [makeEntry("notification", "*")],
    Stop: [makeEntry("stop")],
    SubagentStop: [makeEntry("subagent-stop")],
    SubagentStart: [makeEntry("subagent-start")],
    PreCompact: [makeEntry("pre-compact")],
    SessionStart: [makeEntry("session-start")],
    SessionEnd: [makeEntry("session-end")],
    UserPromptSubmit: [makeEntry("user-prompt-submit")],
  };
}

// Hook types that were previously generated by CAM but are not valid in Claude Code.
// These are removed during merge to fix broken settings.json files.
const INVALID_HOOK_TYPES = new Set(["PostCompact"]);

export function mergeHooks(
  existing: Record<string, unknown>,
  camHooks: HooksConfig,
): Record<string, unknown> {
  const existingHooks = (existing.hooks ?? {}) as Record<string, HookEntry[]>;
  const merged: Record<string, HookEntry[]> = {};

  for (const [hookType, entries] of Object.entries(camHooks)) {
    const existingEntries = existingHooks[hookType] ?? [];

    // Filter out any existing CAM hooks to avoid duplicates
    const nonCamEntries = existingEntries.filter((entry) => !isCamHook(entry));

    // Append CAM hooks at the end
    merged[hookType] = [...nonCamEntries, ...entries];
  }

  // Preserve hook types not managed by CAM, but skip invalid ones
  for (const [hookType, entries] of Object.entries(existingHooks)) {
    if (!(hookType in camHooks) && !INVALID_HOOK_TYPES.has(hookType)) {
      merged[hookType] = entries;
    }
  }

  return {
    ...existing,
    hooks: merged,
  };
}

export function removeCamHooks(
  settings: Record<string, unknown>,
): Record<string, unknown> {
  const hooks = (settings.hooks ?? {}) as Record<string, HookEntry[]>;
  const cleaned: Record<string, HookEntry[]> = {};

  for (const [hookType, entries] of Object.entries(hooks)) {
    const nonCamEntries = entries.filter((entry) => !isCamHook(entry));
    if (nonCamEntries.length > 0) {
      cleaned[hookType] = nonCamEntries;
    }
  }

  const result = { ...settings };
  if (Object.keys(cleaned).length > 0) {
    result.hooks = cleaned;
  } else {
    delete result.hooks;
  }

  return result;
}

export function isCamHook(entry: HookEntry): boolean {
  // Check new format: hooks array with command containing marker
  if (entry.hooks && Array.isArray(entry.hooks)) {
    return entry.hooks.some(
      (h) => h.type === "command" && h.command.includes(CAM_HOOK_MARKER),
    );
  }
  // Legacy format fallback: direct command field
  const legacy = entry as unknown as Record<string, string>;
  if (typeof legacy["command"] === "string") {
    return legacy["command"].includes(CAM_HOOK_MARKER);
  }
  return false;
}

export function listConfiguredCamHooks(
  settings: Record<string, unknown>,
): Array<{ hookType: string; command: string }> {
  const hooks = (settings.hooks ?? {}) as Record<string, HookEntry[]>;
  const result: Array<{ hookType: string; command: string }> = [];

  for (const [hookType, entries] of Object.entries(hooks)) {
    for (const entry of entries) {
      if (isCamHook(entry)) {
        // Extract command from hooks array
        const cmd = entry.hooks?.find(
          (h) => h.type === "command" && h.command.includes(CAM_HOOK_MARKER),
        );
        if (cmd) {
          result.push({ hookType, command: cmd.command });
        }
      }
    }
  }

  return result;
}

export const HOOK_TYPE_DESCRIPTIONS: Record<string, string> = {
  PreToolUse: "Before each tool call (all tools)",
  PostToolUse: "After each tool call (all tools)",
  PostToolUseFailure: "When a tool call fails",
  Notification: "When Claude Code sends a notification",
  Stop: "When the main agent stops",
  SubagentStop: "When a sub-agent (teammate) stops",
  SubagentStart: "When a sub-agent (teammate) starts",
  PreCompact: "Before context compaction",
  SessionStart: "When a Claude Code session starts",
  SessionEnd: "When a Claude Code session ends",
  UserPromptSubmit: "When the user submits a prompt",
};
